* Chapter 3: Do things a Clojure Crash Course** Syntax 

   Clojure code is written in a uniform structure:
   
   1) Literal representations of data structures
   2) Operations 

   #+BEGIN_SRC clojure
   1
   "a string" 
   ["a" "vector" "of" "strings"]
   #+END_SRC

   #+RESULTS:

   Operations are how you do things, '+' is an example of an operation:

   #+BEGIN_SRC clojure
   (+ 1 2 3)
   #+END_SRC

   #+RESULTS:
   : 6
   
   #+BEGIN_SRC clojure
     (str "It was the panda " "in the library " "with a dust buster")
   #+END_SRC

   #+RESULTS:
   : It was the panda in the library with a dust buster
   
** Control flow

   This is the special form for the if statement in clojure, it is very familiar! 
   
   #+BEGIN_SRC clojure
     (if true
       "By Zeus's hammer!"
       "By Aquaman's trident!")
   #+END_SRC

   #+RESULTS:
   : By Zeus's hammer!

   #+BEGIN_SRC clojure
     (if false
       "By Zeus's hammer!"
       "By Aquaman's trident!")
   #+END_SRC

   #+RESULTS:
   : By Aquaman's trident!

   Technically an if statement does not need a second branch, which returns nil.

   #+BEGIN_SRC clojure
     (if false
       "By Odin's Elbow!")p
   #+END_SRC

   #+RESULTS:

   There is some new stuff that you should know: there is 'do', which means multiple expressions can be executed on one branch 
   of your if statement: 

   #+BEGIN_SRC clojure
     (if true
       (do (println "Success!")
	   "By Zeus's hammer!")
       (do (println "Failure!")
	   "By Aquaman's trident!"))
   #+END_SRC

   #+RESULTS:
   : By Zeus's hammer!

   The above code evaluates both expressions in the repl. 

   There is also 'when' which allow you to do multiple things when there is
   no else branch, it's a special if:

   #+BEGIN_SRC clojure
     (when true
       (println "Success!")
       "abra cadabra")
   #+END_SRC

   #+RESULTS:
   : abra cadabra

** nil, true, false, Truthiness, Equality, and Boolean Expressions

   'nil' is used to indicate no value in clojure
   there is obviously true and false

   #+BEGIN_SRC clojure
     (nil? 1)
   #+END_SRC

   #+RESULTS:
   : false

   #+BEGIN_SRC clojure
     (nil? nil)
   #+END_SRC

   #+RESULTS:
   : true

   #+BEGIN_SRC clojure
     (if "bears eat beets"
       "bears beets Battlestar Galactica")
   #+END_SRC

   #+RESULTS:
   : bears beets Battlestar Galactica

   Both 'nil' and 'false' represent logical falsiness.

   The = sign is the equality operator in clojure.

   #+BEGIN_SRC clojure
     (= 1 1)
   #+END_SRC

   #+RESULTS:
   : true
   
   #+BEGIN_SRC clojure
     (= nil nil)
   #+END_SRC

   #+RESULTS:
   : true
   
   #+BEGIN_SRC clojure
     (= 1 2)
   #+END_SRC

   #+RESULTS:
   : false

   'or' and 'and' are interesting operators and work the same as they do 
   in sicp or scheme.

** or and and
*** or
   or returns either the first truthy value or the last value.

   #+BEGIN_SRC clojure
     (or false nil :larg_I_mean_venti :why_cant_I_just_say_large)
   #+END_SRC

   #+RESULTS:
   : :larg_I_mean_venti

   Here the first truthy value is :larg_I_mean_venti, this is because false
   is false and in clojure nil is also falsey.

   #+BEGIN_SRC clojure
     (or (= 0 1) (= "yes" "no"))
   #+END_SRC

   #+RESULTS:
   : false

   #+BEGIN_SRC clojure
     (or nil)
   #+END_SRC

   #+RESULTS:

   Here nil is returned because it is the last value.

*** and
    
    and returns the first falsey value or the last truthy value

   #+BEGIN_SRC clojure
     (and :free_wifi :hot_coffee)
   #+END_SRC

   #+RESULTS:
   : :hot_coffee

   Here the last truthy value is :hot_coffee

   #+BEGIN_SRC clojure
     (and :feelin_super_cool nil false)
   #+END_SRC

   #+RESULTS:

   Here the first falsey value is nil

** Naming Values with def

   #+BEGIN_SRC clojure
     (def failed-protagonist-names
       ["Larry Potter" "Doreen the Explorer" "The Incrdeible Bulk"])
   #+END_SRC

   #+RESULTS:
   : #'user/failed-protagonist-names

   Here failed-protagonist-names has been bound to a string-vector

   #+BEGIN_SRC clojure
     (defn error-message
       [severity]
       (str "OH GOD! IT'S A DISASTER! WE'RE "
	    (if (= severity :mild)
	      "MILDLY INCONVENIENCED!"
	      "DOOOOOOOOOOOOED!")))
   #+END_SRC

   #+RESULTS:
   : #'user/error-message

   Here we have created a function that accepts a single argument
   and then uses that argument to determine what is returned.

   You should see def as a way of defining constants.

** Data Structures

   You can't change a data structure once it is instanciated. So for example
   the first element of a vector cannot be changed in clojure.

   Numbers are extremely easy to manage as clojure just manages them 
   for you. 

   Only double quotes are allowed to deliniate strings.

*** COMMENT Maps

    Maps are similar to dictionaries. They're are a way of associating 
    some vvlaue with some other value.

    #+BEGIN_SRC clojure
      {:first-name "Charlie"
       :last-name "McFishwich"}
    #+END_SRC

    #+RESULTS:

    Here we have associated the key-word :first-name with "Charlie"
    and :last-name with "McFishwich"

    There are two types of maps, hash-maps and sorted. Here we are 
    focused on the sorted kind. 

    #+BEGIN_SRC clojure
      {"string-key" +}
    #+END_SRC

    Here we have associated the "string-key" with the + function.

    Maps can also be nested: 

    #+BEGIN_SRC clojure
      {:name {:first "John" :middle "Jacob" :last "Jingleheimerschmidt"}}
    #+END_SRC

    Map values can be any type: string, numbers, maps, vectors, or even 
    functions.

    There is also a hash-map function:

    #+BEGIN_SRC clojure
      (hash-map :a 1 :b 2)
    #+END_SRC

    You can look up values in maps with the get function: 

    #+BEGIN_SRC clojure
      (get {:a 1 :b 2} :b)
    #+END_SRC

    #+RESULTS:
    : 2

    The below needs to be evaluated in the repl:

    #+BEGIN_SRC clojure
      (get {:a 0 :b {:c "ho hum"}} :b)
    #+END_SRC

    #+RESULTS:
    
    get will return nil if it doesn't find your key, or you can give it 
    a default value to return such as "unicorns?"

    #+BEGIN_SRC clojure
      (get {:a 0 :b 1} :c)
    #+END_SRC

    #+RESULTS:

    #+BEGIN_SRC clojure
      (get {:a 0 :b 1} :c "unicorns?")
    #+END_SRC

    #+RESULTS:
    : unicorns?
    
    There is also the 'get-in' function which allows you to look up values
    that are in nested maps

    #+BEGIN_SRC clojure
      (get-in {:a 0 :b {:c "ho hum"}} [:b :c]) 
    #+END_SRC

    #+RESULTS:
    : ho hum
    
    It's interesting that it uses a vector to do this. 

    Another way to look up a value in a map is to treat the map like a
    function with the key as its argument: 

    #+BEGIN_SRC clojure
      ({:name "The Human Coffeepot"} :name)
    #+END_SRC

    #+RESULTS:
    : The Human Coffeepot

** Keywords
   
   Keywords start with the colon character. They can be used as functions
   to get the corresponding value in a data structure:

   #+BEGIN_SRC clojure
     (:a {:a 1 :b 2 :c 3})
   #+END_SRC

   #+RESULTS:
   : 1

   This is an example of how to use :a to get the value stored in the map,
   the same thing using get would be...

   #+BEGIN_SRC clojure
     (get {:a 1 :b 2 :c 3} :a)
   #+END_SRC

   #+RESULTS:
   : 1

   I like the keyword way because it jsut reads nicer.

   #+BEGIN_SRC clojure
     (:d {:a 1 :b 2 :c 3} "No gnome knows homes like Noah knows")
   #+END_SRC

   Here we have provided a default value for the expression. 

   Get into the habit of using keywords as functions, I'm sure we will
   see more of how this is done as we procede with the book.

** Vectors

   A vector is created using square brackets,

   #+BEGIN_SRC clojure
     (get [3 2 1] 0)
   #+END_SRC

   above is how you get the first element from a vector. 

   #+BEGIN_SRC clojure
     (get ["a" {:name "Pugsley Winterbottom"} "c"] 1)
   #+END_SRC

   #+RESULTS:

   If we send the above to the repl then it returns the dictionary which 
   is at the first index.

   #+BEGIN_SRC clojure
     (vector "creepy" "full" "moon")
   #+END_SRC

   vectors can be created using the vector function as shown above. 

   You can add elements to the end of a vector by using the 'conj' function

   #+BEGIN_SRC clojure
     (conj [1 2 3] 4)
   #+END_SRC

   #+RESULTS:

** Lists
   
   Lists are created by using the single quote. This makes sense why the 
   strings must be deliniated using the double quotes

   #+BEGIN_SRC clojure
     '(1 2 3 4)
   #+END_SRC

   #+RESULTS:

   The nth element for a list can be gotten by using 'nth'

   #+BEGIN_SRC clojure
     (nth '(:a :b :c) 0)
   #+END_SRC

   #+RESULTS:
   : :a

   Retrieving elements from a vector is quicker than using nth because 
   nth has to loop down a list. 

   When using 'conj' with a list, elements are added to the front of a list

   #+BEGIN_SRC clojure
     (conj '(1 2 3) 4)
   #+END_SRC

   You can create a list using the 'list' function

   #+BEGIN_SRC clojure
     (list 1 2 3 4)
   #+END_SRC

   #+RESULTS:
   
   Using a list tends to be the case when you are writing a macro or when 
   you need to easily be able to add items to the beginning of a list. 

** Sets

   Sets are collections of unique vlauese, there are hash sets and sorted 
   sets in clojure.

   #+BEGIN_SRC clojure
     #{"kurt vonnegut" 20 :icicle}
   #+END_SRC

   #+RESULTS:
   : #{20 :icicle "kurt vonnegut"}

   You can also use hash-set to create a set: 

   #+BEGIN_SRC clojure
     (hash-set 1 1 2 2)
   #+END_SRC

   #+RESULTS:
   : #{1 2}

   Notice that a set can only contain unique values.
   When you try and create a set with multiple same values then it reduces 
   to unique values. 

   #+BEGIN_SRC clojure
     (conj #{:a :b} :b)
   #+END_SRC

   #+RESULTS:
   : #{:b :a}

   If you try and add a value that is already contained in the hash set 
   you get the same hash set. 

   There is also a set function

   #+BEGIN_SRC clojure
     (set [3 3 3 4 4])
   #+END_SRC

   #+RESULTS:
   : #{4 3}

   You can also check for membership within a set using the contains? 
   function

   #+BEGIN_SRC clojure
     (contains? #{:a :b} :a)
   #+END_SRC

   #+RESULTS:
   : true

   #+BEGIN_SRC clojure
     (contains? #{:a :b} 3)
   #+END_SRC

   #+RESULTS:
   : false

   #+BEGIN_SRC clojure
     (contains? #{nil} nil)
   #+END_SRC

   #+RESULTS:
   : true

   You can also use key words as functions

   #+BEGIN_SRC clojure
     (:a #{:a :b})
   #+END_SRC

   #+RESULTS:
   : :a

   You can also use the get function

   #+BEGIN_SRC clojure
     (get #{:a :b} :a)
   #+END_SRC

   #+RESULTS:
   : :a

   #+BEGIN_SRC clojure
     (get #{:a nil} nil)
   #+END_SRC

   #+RESULTS:

   #+BEGIN_SRC clojure
     (get #{:a :b} "kurt vonnegut")
   #+END_SRC

   #+RESULTS:

   Testing whether a set contains nil will always return nil so contains? 
   may be a better option when you are testing specifically for membership.

** Simplicity

   It is better to have 00 functions operate on one data structure than 
   10 functions on 10 data structures.

** Functions
*** Calling Functions

    You can create expressions that return functions. In the below case 
    the first truthy value is +, so the + function is returned

    #+BEGIN_SRC clojure
      (or + -)
    #+END_SRC

    #+RESULTS:
    : #function[clojure.core/+]

    We can also use the functional expression if we want to

    #+BEGIN_SRC clojure
      ((or + -) 1 2 3)
    #+END_SRC

    #+RESULTS:
    : 6

    Here are some more examples of functional expressions

    #+BEGIN_SRC clojure
      ((and (= 1 1) +) 1 2 3)
    #+END_SRC

    #+RESULTS:
    : 6

    #+BEGIN_SRC clojure
      ((first [+ 0]) 1 2 3)
    #+END_SRC

    #+RESULTS:
    : 6

    numbers and strings are not functions. If you get an error which says
    <x> cannot be cast to clojure.lang.IFn just means that you're trying to 
    use something as a function when it's not.

    The map function is an example of a function that takes a function as
    an argument. It is an example of a higher order function: 

    #+BEGIN_SRC clojure
      (map inc [0 1 2 3 4])
    #+END_SRC

    #+RESULTS:

    It's important to note that eventhough map was given a vector it
    returns a list.

*** How functions differ from macros and special forms

    #+BEGIN_SRC clojure
      (if statement
	true
	false)
    #+END_SRC
    
    Clojure's if statement is the same as the ones we are familiar in lisp.
    Only one of the branches is evaluated dependendent on the statement.

    A special form cannot be used as an argument to a function. 
    
    'if' is a special form so the below would never be written in Clojure. 

    #+BEGIN_SRC clojure
      (map if [1 2 3])
    #+END_SRC
    
*** Defining functions 

    Here is a simple function in clojure that takes an argument and then 
    returns sa string with the arguments value slotted in it. 

    #+BEGIN_SRC clojure
      (defn too-enthusiastic
	"Return a cheer that might be a bit too enthusiastic"
	[name]
	(str "OH. MY GOD! " name " YOU ARE MOST DEFINITELY LIKE THE BEST "
	     "MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE!"))
    #+END_SRC

    #+RESULTS:
    : #'user/too-enthusiastic



    #+BEGIN_SRC clojure
      (defn no-params
	[]
	"I take no parameters!")
    #+END_SRC

    #+RESULTS:
    : #'user/no-params


    #+BEGIN_SRC clojure
      (defn one-param
	[x]
	(str "I take one parameter: " x))
    #+END_SRC

    #+RESULTS:
    : #'user/one-param

    #+BEGIN_SRC clojure
      (defn two-params
	[x y]
	(str "Two parameters! That's nothing! Pah! I will smoosh them "
	     "together to spite you! " x y))
    #+END_SRC

    #+RESULTS:
    : #'user/two-params

    Different numbers of arguments can cause differnt parts of a body of a 
    function to be called. This is called arity. 

    #+BEGIN_SRC clojure
      (defn multi-arity
	;; 3-arity arguments and body
	([first-arg second-arg third-arg]
	 (do-things first-arg second-arg third-arg))
	;; 2-arity arguments and body
	([first-arg second-arg]
	 (do-things first-arg second-arg))
	;; 1-arity arguments and body
	([first-arg]
	 (do-things first-arg)))
    #+END_SRC

    #+BEGIN_SRC clojure
      (defn x-chop
	"Describe the kind of chop you're inflicting on someone"
	([name chop-type]
	 (str "I " chop-type " chop " name "! Take that!"))
	([name]
	 (x-chop name "karate")))
    #+END_SRC

    #+RESULTS:
    : #'user/x-chop

    #+BEGIN_SRC clojure
      (x-chop "kaney" "slap")
    #+END_SRC

    #+RESULTS:
    : I slap chop kaney! Take that!

    #+BEGIN_SRC clojure
      (x-chop "kanye")
    #+END_SRC

    #+RESULTS:
    : I karate chop kanye! Take that!

    This second evaluation is a bit weird... but it's just a recursive call!
    (x-chop calls itself with "karate" already supplied as its argument.

    #+BEGIN_SRC clojure
      (defn weird-arity
	([]
	 "Destiny dressed you this morning, my friend, and now Fear is
	  trying to pull of your pants. If you give up, if you give in, 
	  you're gonanna end up naked with Fear just standing there laughing
	  at you dangling unmentionables! - the Tick")
	([number]
	 (inc number)))
    #+END_SRC

    This is an example I was more expecting because each block does 
    something different dependent on the arguments that are supplied.
    This is considered bad form creating a function that has two bodies 
    that are completely unrelated.  

    You can also define variable arity functions. This means that the 
    arguments supplied are put into a list with the name which is followed
    by the ampersand.

    #+BEGIN_SRC clojure
      (defn codger-communication
	"Documenation: "
	[whippersnapper]
	(str "Get off my lawn, " whippersnapper "!!!"))

      (defn codger
	"Documenation: "
	[& whippersnappers]
	(map codger-communication whippersnappers))
    #+END_SRC

    #+RESULTS:

    #+BEGIN_SRC clojure
      (codger "Billy" "Anne-Marie" "The Incredible Bulk")
    #+END_SRC

    #+RESULTS:

    codger-communication is a function that is a applied to a single 
    string. 
    This function that is applied to a single string is the applied to 
    a list of strings via map! It's genious. Really is.

    #+BEGIN_SRC clojure
      (defn favorite-things
	"Documenation: "
	[name & things]
	(str "Hi, " name ", here are my favoirte things: "
	     (clojure.string/join ", " things)))
    #+END_SRC

    #+RESULTS:
    : #'user/favorite-things

**** Destructuring

     #+BEGIN_SRC clojure
       ;; Return the first element of a collection
       (defn my-first
	 [[first-thing]] ; Notice that first-thing is withing a vector
	 first-thing)
     #+END_SRC

     #+RESULTS:
     : #'user/my-first

     This is a very foreign to me. It's clear that the argument to 
     my-first is a vector. I think if you supply a vector, the first element
     in the vector will be bound to the symbol "first-thing" and then 
     first-thing is returned. I think that is how it is working... 

     #+BEGIN_SRC clojure
       (my-first ["oven" "bike" "war-axe"])
     #+END_SRC

     #+RESULTS:
     : oven

     This is just a clever way of doing assignment on mass in a 
     meaning full way.

     You can destructure a vector by naming some of the arguments and then 
     you can use a rest parameter for the rest of the vector which you 
     can't be arsed to name.

     #+BEGIN_SRC clojure
       (defn chooser
	 [[first-choice second-choice & unimportant-choices]]
	 (println (str "Your first choice is: " first-choice))
	 (println (str "Your second choice is: " second-choice))
	 (println (str "We're ignoring the rest of your choices. "
		       "Here they are in case you need to cry over them: "
		       (clojure.string/join ", " unimportant-choices))))
     #+END_SRC

     #+RESULTS:
     : #'user/chooser

     You can also destructure maps.

     #+BEGIN_SRC clojure
       (defn announce-treasure-location
	 [{:lat lat :lng lng}]
	 (println (str "Treasure lat: " lat))
	 (println (str "Treasure lng: " lng)))
     #+END_SRC

     I've written the map in an order that makes sense to me, 
     so it goes {key1 value1 key2 value2 ...} but it does seem as though 
     clojure has the flexibility to run the map in a weird order IMO, i.e.
     {value1 key1 value2 key2...} it doesn't seem to matter. I think this 
     is because it is clear which is the keyword.

     There is a shorter syntax for creating the same function as above
     
     #+BEGIN_SRC clojure
       (defn announce-treasure-location
	 [{:keys [lat lng]}]
	 (println (str "Treasure lat: " lat))
	 (println (str "Treasure lng: " lng)))
     #+END_SRC

     #+RESULTS:
     : #'user/announce-treasure-location

     You can see how the syntax has been shortened as a result.

     We can go one step further by using the ':as' keyword.

     #+BEGIN_SRC clojure
       (defn receive-treasure-location
	 [{:keys [lat lng] :as treasure-location}]
	 (println (str "Treasure lat: " lat))
	 (println (str "Treasure lng: " lng))
	 (steer-ship! treasure-location))
     #+END_SRC

     The above doesn't execute, but we see an example of binding a dictionary
     withing a function to a symbol 'treasure-location' which is then 
     supplied to the steer-ship! function. Clever.

**** Function Body

     This function contains three forms of which "joe" is spat out. 

     #+BEGIN_SRC clojure
       (defn illustrative-function
	 []
	 (+ 1 304)
	 30
	 "joe")
     #+END_SRC

     #+RESULTS:
     : #'user/illustrative-function

     Here's another function body which uses an if expression

     #+BEGIN_SRC clojure
       (defn number-comment
	 [x]
	 (if (> x 6)
	   "Oh my gosh! what a big number!"
	   "That number's OK, I guess"))
     #+END_SRC

     #+RESULTS:
     : #'user/number-comment

     There is no such thing as a special function. They all work the 
     same. 
     
*** Anonymous functions

    There are two ways for creating anonymous functions in Clojure:

    #+BEGIN_SRC clojure
      (fn [param-list]
	function-body)
    #+END_SRC

    We are quite comfortable with these because you have been using loads of these when studying SICP.

    #+BEGIN_SRC clojure
      (map (fn [name] (str "Hi, " name)) 
	     ["Darth Vader" "Mr. Magoo"])
    #+END_SRC

    #+RESULTS:
    
    The above will evaluate in the repl. And you can see how the anonymous
    function has been applied to multiple arguments again very easily. 

    #+BEGIN_SRC clojure
      ((fn [x] (* x 3)) 8)
    #+END_SRC

    #+RESULTS:
    : 24

    Anonymous functions have all the properties of normal functions. 
    The parameter lists and function bodies work in exactly the same manner.
    This means you can use destructuring, rest parameters, and so on. You can 
    even assoiate your anonymous function with a name, which should be 
    a surprise.  

    #+BEGIN_SRC clojure
      (def my-special-multiplier (fn [x] (* x 3)))
    #+END_SRC

    #+BEGIN_SRC clojure
      (my-special-multiplier 10)
    #+END_SRC

    There is an even more concise notation for an anonymous function 
    which is shown below. It is VERY concise.

    #+BEGIN_SRC clojure
      (#(* % 3) 8)
    #+END_SRC

    #+RESULTS:
    : 24

    The #() indicates that there is an anonymous functioni and the
    % symbol acts as the anonymous argument. Neat. 

    #+BEGIN_SRC clojure
      (map #(str "hi, " %)
	   ["Darth Vader" "Mr. Magoo"])
    #+END_SRC

    #+RESULTS:

    The above evaluates in the repl. 

    If the anonymous function takes more than one argument then you can 
    indicate this as demonstrated in the following example

    #+BEGIN_SRC clojure
      (#(str %1 " and " %2) "cornbread" "butter beans")
    #+END_SRC

    #+RESULTS:
    : cornbread and butter beans

    You can also pass in the rest parameter if you really want to be a boss

    #+BEGIN_SRC clojure
      (#(identity %&) 1 "blarg" :yip)
    #+END_SRC

    #+RESULTS:

*** Returning functions

    There is an explaination of what a closure is here. There are functions 
    that return other functions. These returned functions are closures. 
    This means they have access to all the variables that were created 
    when the function was created. Here is an example: 

    #+BEGIN_SRC clojure
      (defn inc-maker
	"Create a custom incrementor"
	[inc-by]
	#(+ % inc-by))
    #+END_SRC

    #+BEGIN_SRC clojure
      (def inc3 (inc-maker 3))
    #+END_SRC

    #+RESULTS:
    : #'user/inc3
    
    #+BEGIN_SRC clojure
      (inc3 7)
    #+END_SRC

    #+RESULTS:
    : 10
    
    inc3 the returned function in this case. When this function is created
    it has access to inc-by. inc-by is in the "scope". I think you need 
    to think about this a bit more but also think about how this is 
    evaluated. I think it makes sense kind of.  

** Pulling It All Together

   In this section you will about let expressions, loops and regular 
   expressions.

   Below we have defined a vector of maps, where each body part's name 
   and relative size has been given.

   #+BEGIN_SRC clojure
     (def asym-hobbit-body-parts [{:name "head" :size 3}
				  {:name "left-eye" :size 1}
				  {:name "left-ear" :size 1}
				  {:name "mouth" :size 1}
				  {:name "nose" :size 1}
				  {:name "neck" :size 2}
				  {:name "left-shoulder" :size 3}
				  {:name "left-upper-arm" :size 3}
				  {:name "chest" :size 10}
				  {:name "back" :size 10}
				  {:name "left-forearm" :size 3}
				  {:name "abdomen" :size 6}
				  {:name "left-kidney" :size 1}
				  {:name "left-hand" :size 2}
				  {:name "left-knee" :size 2}
				  {:name "left-thigh" :size 4}
				  {:name "left-lower-leg" :size 3}
				  {:name "left-achilles" :size 1}
				  {:name "left-foot" :size 2}])
   #+END_SRC

   #+RESULTS:
   : #'user/asym-hobbit-body-parts

   We then make this helper function

   #+BEGIN_SRC clojure
     (defn matching-part
       [part]
       {:name (clojure.string/replace (:name part) #"^left-" "right-")
	:size (:size part)})

     (defn symmetrize-body-parts 
       "Expects a seq of maps that have a :name and :size"
       [asym-body-parts]
       (loop [remaining-asym-parts asym-body-parts
	      final-body-parts []]
	 (if (empty? remaining-asym-parts)
	   final-body-parts
	   (let [[part & remaining] remaining-asym-parts]
	     (recur remaining
		    (into final-body-parts
			  (set [part (matching-part part)])))))))
   #+END_SRC

   #+RESULTS:


   #+BEGIN_SRC clojure
   (symmetrize-body-parts asym-hobbit-body-parts)
   #+END_SRC

   #+RESULTS:

*** let

   Let is another way of binding values to symbols: 

   #+BEGIN_SRC clojure
     (let [x 3]
       x)
   #+END_SRC

   #+RESULTS:
   : 3

   #+BEGIN_SRC clojure
     (def dalmatian-list
       ["Pongo" "Perdita" "Puppy 1" "Puppy 2"])

     (let [dalmatians (take 2 dalmatian-list)]
       dalmatians)
   #+END_SRC

   let introduces a new scope when it is called. In the case above it 
   binds dalmatians to the result of the expression (take 2 dalmatian-list).

   #+BEGIN_SRC clojure
     (def x 0)
     (let [x 1] x)
   #+END_SRC

   #+RESULTS:

   In the global scope x is now bound to 0. Within the scope of the let 
   x is bound to 1. 

   You can reference existing bindings in your let binding: 

   #+BEGIN_SRC clojure
     (def x 0)
     (let [x (inc x)] x)
   #+END_SRC

   #+RESULTS:

   In the above example, the x that is being referred to in the let expression
   is the x that is instantiated in the global scope.

   #+BEGIN_SRC clojure
     (let [[pongo & dalmatians] dalmatian-list]
       [pongo dalmatians])
   #+END_SRC

   Ok so something cool is going on here. Above is an example of using 
   destructuring with a rest paramater. pongo is bound to the first element
   in the dalmatian-list and the rest of the dalmatian list is bound to 
   dalmatians.

   The value of the let expression is the last form within it which is in this 
   case the vector [pongo dalmatians].
   
   let expressions provide clarity by allowing you to name things. 
   let expressions allow you to evaluate an expression only once and then use the result.
   This has value when doing an API call.

   Let's now view that complex let expression again:

   #+BEGIN_SRC clojure
     (let [[part & remaining] remaining-asym-parts]
       (recur remaining
	      (into final-body-parts
		    (set [part (matching-part part)]))))
   #+END_SRC

   We will learn about recur later but you can see how part is associated with the first 
   element in the remaining-asym-parts and remaining is associated with the rest of the
   list. 

   #+BEGIN_SRC clojure
     (into final-body-parts
	   (set [part (matching-part part)]))
   #+END_SRC

   final-body-parts is the resultant vector-map. Each unique set of 
   parts are inserted into the final-body-parts vector map, and this is 
   ensured by using set. part and (matching-part part) can be the same thing
   which is why set is required to remove duplicates.

   #+BEGIN_SRC clojure
     (into [] (set [:a :a]))
   #+END_SRC

   #+RESULTS:

   You need to evalute the parts of this carefully, but what I really like 
   about the above example is how you see how the data is moving through 
   the evaluations 

   (set [:a :a]) -> #{:a}
   
   (into [] #{:a}) -> [:a]

   You can see how the unique :a has travelled into the vector.  

   Let's see what the let expression would look like if we didn't use it

   #+BEGIN_SRC clojure
     (recur (rest remaining-asym-parts)
	    (into final-body-parts
		  (set [(first remaining-asym-parts) (matching-part (first
     remaining-asym-parts))])))
   #+END_SRC

   This is super convoluted, so let allows us to simplify the code by giving
   local names to things. 

*** loop

    loop is another example of how to perform recursion in clojure. 

    #+BEGIN_SRC clojure
      (loop [iteration 0]
	(println (str "Iteration " iteration))
	(if (> iteration 3)
	  (println "Goodbye!")
	  (recur (inc iteration))))
    #+END_SRC

    #+RESULTS:

    The explaination of what is happening here is insane. 
    From what I can tell loop allows you to intialize a variable in this 
    case iteration. recur causes the beginning of the loop to be called 
    again and again. The loop ends when the if statement returns true 
    and "Goodbye!". 

    Now let's consider how the book describes things...

    It says iteration is bound to an initial value of 0.  
    Next a message is produced that contains the current value of iteration.
    Then the value of iteration is checked and if it is greater than 3 
    then the loop ends by printing "Goodbye!". 
    
    Otherwise we recur... 

    loop is kind of creating an anoymous function that updates itself.
    it's a self updating anonymous function with a parameter iteration
    that is called within itslef where each pass its own self update
    it passese in (inc iteration) rather than iteration. This is how it 
    updates itself.

    We can define the same loop using a recursive function...

    #+BEGIN_SRC clojure
      (defn recursive-printer
	([]
	 (recursive-printer 0))
	([iteration]
	 (println iteration)
	 (if (> iteration 3)
	   (println "Goodbye")
	   (recursive-printer (inc iteration)))))

      (recursive-printer)
    #+END_SRC
    
    Above is how the book writes the recursive function and below is 
    how I would write this function: 

    #+BEGIN_SRC clojure
      (defn recursive-printer
	"Documenation: "
	[iteration]
	(println iteration)
	(if (> iteration 3)
	  (println "Goodbye")
	  (recursive-printer (inc iteration))))
    #+END_SRC

    #+RESULTS:
    : #'user/recursive-printer

    I would then create a wrapper so that you don't need to supply an 
    argument

    #+BEGIN_SRC clojure
      (defn recursive-printer
	[]
	(defn recursive-printer
	[iteration]
	(println iteration)
	(if (> iteration 3)
	  (println "Goodbye")
	  (recursive-printer (inc iteration))))
	(recursive-printer 0))
    #+END_SRC

    #+RESULTS:
    : #'user/recursive-printer

    Now this form isn't that far from the design in the book...

    #+BEGIN_SRC clojure
      (defn recursive-printer
	[]
	(recursive-printer 0)
	(defn recursive-printer
	[iteration]
	(println iteration)
	(if (> iteration 3)
	  (println "Goodbye")
	  (recursive-printer (inc iteration)))))
    #+END_SRC

    #+RESULTS:
    : #'user/recursive-printer

    Anyway, the recursive function is not the most efficient way of doing 
    looping in Clojure. It is actually best to use the loop construct. 

*** regular expressions

    regex are tools for performing pattern matching on text. 
    They start with a # symbol and a surrounded with quotaton marks.

    #"^left-" means match any string that starts with "left-", the carrat
    is used to mean starts with. 

    You can test regular expressions using the re-find function to see 
    if there is a match, otherwise nil will be returned when it is 
    evaluated. So this is a way of building up your reg-expressions! 

    #+BEGIN_SRC clojure
      (re-find #"^left-" "left-eye")
    #+END_SRC

    #+RESULTS:
    : left-

    #+BEGIN_SRC clojure
      (re-find #"^left-" "cleft-eye")
    #+END_SRC

    #+RESULTS:
  
    #+BEGIN_SRC clojure
      (re-find #"^left-" "wongleblart")
    #+END_SRC

    #+RESULTS

    We can see how matching part works in action now: 

    #+BEGIN_SRC clojure
      (matching-part {:name "left-eye" :size 1})
    #+END_SRC

    #+RESULTS:
    
    #+BEGIN_SRC clojure
      (matching-part {:name "head" :size 1})
    #+END_SRC

    #+RESULTS:

    something different dependent on the arguments that are supplied

    
** Better Symmetrizer with reduce

    There is an inbuilt abstraction in clojure for the process 
   "process each element in a sequence and build a result". The function
   for this is called reduce.

   #+BEGIN_SRC clojure
     (reduce + [1 2 3 4])
   #+END_SRC

   #+RESULTS:
   : 10

   This is like telling clojure to do this 

   #+BEGIN_SRC clojure
     (+ (+ (+ 1 2) 3) 4)
   #+END_SRC

   #+RESULTS:
   : 10

   So let's now think about how exactly the reduce function is working

   1) Apply the given function to the first two elements of a sequence

   2) Apply the given function to the result and the next element of the 
      sequence

   3) Keep repeating step two until the end of the sequence


   It's also important to note that reduce also takes an optional intial 
   value

   #+BEGIN_SRC clojure
     (reduce + 15 [1 2 3 4])
   #+END_SRC

   #+RESULTS:
   : 25

   The book now takes us to an implementation of how reduce could be 
   implemented: 

   #+BEGIN_SRC clojure
     (defn my-reduce
       ([f initial coll]
	(loop [result initial
	       remaining coll]
	  (if (empty? remaining)
	    result
	    (recur (f result (first remaining)) (rest remaining)))))
       ([f [head & tail]]
	(my-reduce f head tail)))
   #+END_SRC

   Now we have a description of how my-reduce should work but let's see
   if we can implement it using recursion ourselves and then convert it 
   to the form that we see above which uses the loop construct.

*** Exercise: Design your own reduce

    reduce is an inbuilt function in Clojure and is an extremely useful
    abstraction for bulding a result from a sequence of elements 

    The way that reduce works is as follows:

    1) Apply the given function to the first two elements of a sequence

    2) Apply the given function to the result and the next element of the 
      sequence

    3) Keep repeating step two until the end of the sequence

    So for example:    

    (reduce + [1 2 3 4]) 
    
    tells Clojure to evaluate something like this: 

    (+ (+ (+ 1 2) 3) 4)

    In Clojure for the Brave and True we are given this example 
    for how reduce could be written in Clojure.

    reduce can also take an intial argument

    (reduce + 15 [1 2 3 4]) -> 25

    #+BEGIN_SRC clojure
     (defn CLBT-reduce
       ([f initial coll]
	(loop [result initial
	       remaining coll]
	  (if (empty? remaining)
	    result
	    (recur (f result (first remaining)) (rest remaining)))))
       ([f [head & tail]]
	(my-reduce f head tail)))
   #+END_SRC

    This version is even more powerful because it also takes into 
    account an initial starting value.
 
    The goal of this exercise is to emulate how this function could have 
    been designed from first principles using the techniques learnt in 
    Structure and Interpretation of Computer programs build a functioning 
    version of reduce called "my-reduce". 
 
    Once this has been done, make use of the extra tools that clojure gives
    you to refactor your version of my-reduce so that it looks like the one 
    which is given in Clojure for the Brave and True.

    Then make use of reduce with several functions of your own design to 
    make a vector of maps containing data you wish. 

**** First Thoughts

    So we are trying to implement the simplest form of reduce
    which will take the vector and recursively break it down.
    I want to do the simplesr case which takes a function that is arithmentic
    and a vector as argument. We can worry about more interesting arguments
    later.

    Let's build this up then... 

**** Case 1
     
     f = + and coll = [1] -> 1 
 
     The reason being that the "second element" is nil and the "result" 
     is the first element. 
     So how do we define the "second element" a.k.a the first element of the 
     rest? 
     Well it's the "first" element of the rest. 
     If the first element of the rest is nil then our function should return
     the result. 
     We should bind result to the first element then... 
     However, I think we can take adavantage of the destructuring that is inbuilt
     into clojure to make this easier for us.   
 
     #+BEGIN_SRC clojure
     (defn my-reduce
       [f coll]
       (let [[first second & rest] coll]
	 (println "first: " first "second: " second)))
     #+END_SRC
 
     Side Note: Does destructuring work for functions with multiple arguments
     of different type? I don't think it does having tried and done some reading.
 
     Ok so let's just get this first case to work in the way we expect.
 
     #+BEGIN_SRC clojure
     (defn my-reduce
       [f coll]
       (let [[first second & rest] coll]
	 (if (nil? second)
	   first)))
     #+END_SRC
 
     #+RESULTS:
     : #'user/my-reduce
 
     #+BEGIN_SRC clojure
       (my-reduce + [1])
     #+END_SRC

     #+RESULTS:
     : 1

**** Case 2 

     So we now want to extend the function out so that it works 
     for more complex cases as stated below: 

     f = + and coll = [1 2] -> 3
    
     f = - and coll = [3 2 1] -> 0  

     f = - and coll = [1 2 3] -> -4 

     We need a value to be returned if the vector has 2 values which is 
     why I've introduced a let-if block which allows me to return a value 
     if I have a vector of only two values. 
     At this point, I know I need a recursive call of the function if I 
     have a vector of 3 or more values so the final step is to make sure 
     that the recursive call does what I want it to do. 
     We know that we are constructing the result with the function always 
     as at the first position i.e. (f(f(f(f...)...)...)...) 
     so that's why it goes first in the final expression. 
     The function has to be applied to the result and the next element of 
     the sequence and the next element of element has to be a my-reduce 
     expression where the rest is the input argument hence...
    
     #+BEGIN_SRC clojure
     (defn my-reduce
       [f coll]
       (let [[first second & rest] coll]
	 (if (nil? second)
	   first
	   (let [result (f first second)]
	     (if (nil? rest)
	       result
	       (f result (my-reduce f rest)))))))
     #+END_SRC 

     #+BEGIN_SRC clojure
     (my-reduce + [1 2])
     #+END_SRC

     #+RESULTS:
     : 3

     #+BEGIN_SRC clojure
     (my-reduce - [3 2 1])
     #+END_SRC

     #+RESULTS:
     : 0

     #+BEGIN_SRC clojure
     (my-reduce - [1 2 3])
     #+END_SRC

     #+RESULTS:
     : -4

**** Case 3

     #+BEGIN_SRC clojure
       (defn my-reduce
	 [f initial coll]
	 (let [[first-of-coll second-of-coll & rest] coll]
	   (if (nil? second-of-coll)
	     (f initial first-of-coll)
	     (f (f initial first-of-coll)
		(my-reduce-recur second-of-coll rest)))))
     #+END_SRC 

     This is a really interesting problem but it is also difficult
     because trying to slot in the centre of the evaluation 
     is actually really difficult when dealing with a number 
     and a vector. 
     At the moment I can think something that will evaluate like
     
     (f (f initial first) (f (f (f .... (f second third) fourth ...)))

     and this isn't what we are after and I'm just not sure what to 
     do  and I don't want to waste anymore time trying for 
     now. I may come back to this one day when I'm better at lisp.
     Continue.
**** Converting my-reduce so that it uses the loop construct

     #+BEGIN_SRC clojure
       (loop [iteration 0]
	 (println (str "Iteration " iteration))
	 (if (> iteration 3)
	   (println "Goodbye!")
	   (recur (inc iteration))))
     #+END_SRC
    
     #+BEGIN_SRC clojure
       (defn my-reduce
	 [f coll]
	 (let [[first second & rest] coll]
	   (if (nil? second)
	     first
	     (let [result (f first second)]
	       (if (nil? rest)
		 result
		 (f result (my-reduce f rest)))))))
     #+END_SRC 

     So loop allows you to initialize a variable and then build a 
     result from the loop.

     #+BEGIN_SRC clojure
       (defn my-reduce
	 [f coll]
	 (loop [remaining coll
		result 0]
	   (if (empty? remaining)
	     result
	     (let [[part & rest-of-remaining] remaining]
	       (recur rest-of-remaining (f part result))))))
     #+END_SRC

     #+RESULTS:
     : #'user/my-reduce

     I'm not sure how you would make this more general and I also 
     have no idea how this is evalauting.

     Using a loop forces you to decide what the data structure that
     is going to be out is going to be. 

     reduce on the other hand is an interesting abstraction because
     you can feed it different types of arguments and it will produce
     different types of data. 

     This actually isn't the case if we remind ourselves of 
     how it could be implmented. 

     #+BEGIN_SRC clojure
       (defn my-reduce
	 ([f initial coll]
	  (loop [result initial
		 remaining coll]
	    (if (empty? remaining)
	      result
	      (recur (f result (first remaining)) (rest remaining)))))
	 ([f [head & tail]]
	  (my-reduce f head tail)))
     #+END_SRC

   Anyway, we have now spend sometime thinking about reduce and how it 
   is a powerful abstraction. Let's now see it in use as it's refactored 
   into symmetrize-body-parts

   #+BEGIN_SRC clojure
     (defn matching-part
       [part]
       {:name (clojure.string/replace (:name part) #"^left-" "right-")
	:size (:size part)})

     (defn better-symmetrize-body-parts
       "Expects a seq of map that have a :name and :size"
       [asym-body-parts]
       (reduce (fn [final-body-parts part]
		 (into final-body-parts (set [part (matching-part part)])))
	       []
	       asym-body-parts))

     ;(better-symmetrize-body-parts asym-hobbit-body-parts)

   #+END_SRC

   #+RESULTS:

*** COMMENT Spider-Expander

    If the body part contains leg or it contains eye we want to 
    have a set of legs and a set of eyes created. 
    
    To do this we are going to use the matching part from earlier
    to create a function as a template. 

    We are also probably going to want to use reduce to create 
    our spider expander... 

    What we are trying to do is to make symmetrize-body-parts
    more generic. 
    
    We want the case where if one of the maps in the 
    asym-hobbit-parts contains "eye", "shoulder", "arm", 
    "upper-arm", "forearm", "hand", "knee", "thigh", "leg", 
    "achilles", "foot" then we want to have our own special 
    function for that... 

    Well we can make a more general version of symmetrize-body-parts
    by adding a function to the arguments that are passed in and 
    calling the new function expand-body-parts<sclojure

    #+BEGIN_SRC clojure
      (defn expand-body-parts
	"Expects a seq of map that have a :name and :size"
	[body-parts f]
	(reduce (fn [final-body-parts part]
		  (into final-body-parts (f part)))
		[]
		body-parts))

      
    #+END_SRC

    This now means we can rewrite symmetrize-body-parts in terms
    of expand-body-parts I think. 

    #+BEGIN_SRC clojure
      (defn symmetrize-body-parts
	"Documenation: "
	[asym-body-parts]
	(expand-body-parts asym-body-parts 
			   (fn [part]
			     (matching-part part)))) 
    #+END_SRC

    #+RESULTS:
    : #'user/symmetrize-body-parts

    Oh baby look how nice and easy this looks to use.

    It's just so dreamy and nice to use. 

    I'm a bit confused why we no longer need the anonymous function 
    to have a body of (set [part (f part)]). But at the same time 
    I kind of don't really care! It works. Move on.
    
** Hobbit Violence

   We are now going to define hit which will hit the random body
   parts at will

   #+BEGIN_SRC clojure
     (defn hit
       [asym-body-parts]
       (let [sym-parts (better-symmetrize-body-parts asym-body-parts)
	     body-part-size-sum (reduce + (map :size sym-parts))
	     target (rand body-part-size-sum)]
	 (loop [[part & remaining] sym-parts
		accumulated-size (:size part)]
	   (if (> accumulated-size target)
	     part
	     (recur remaining (+ accumulated-size (:size (first remaining))))))))
   #+END_SRC

   #+RESULTS:
   : #'user/hit

   Let's break this down: 

   #+BEGIN_SRC clojure
     (def sym-parts (better-symmetrize-body-parts asym-hobbit-body-parts))
   #+END_SRC

   So the map creates a list of all the numbers associated with :size
   that's in the vector map.

   #+BEGIN_SRC clojure
     (def body-part-size-sum (reduce + (map :size sym-parts)))
   #+END_SRC

   The rand function then generates a number between 1 and the 
   body-part-size-sum which is 85 in this case. 

   #+BEGIN_SRC clojure
      (def target (rand body-part-size-sum))
   #+END_SRC

   #+RESULTS:
   : #'user/target

   The loop then processes the parts and as it loops it aggregates
   acculated-size on each pass of the loop until it is greater than
   the target. It is at this point that the random part is spat 
   out. 

   #+BEGIN_SRC clojure
   (hit asym-hobbit-body-parts)
   #+END_SRC

   #+RESULT
* Chapter 4: Core Funtions in Depth
** Programming to Abstractions

   Functions like 'map' work on all the different data structures
   in clojure. This is different to elisp where there is a map which
   works for a hash-set and a map for a sequence and so on. 
   There isn't an overarching map, for some reason. 
   
*** Treating Lists, Vectors, Sets, and Maps as Sequences

    Map is best thought in terms of the sequence abstraction.
    As in a collection of objects with before and after relation-
    ships. A -> B -> C and so on... 

    map and reduce are examples of functions that are best thought
    interms of the sequence abstraction, in that they take "sequences"
    as objects.

    "seq functions" is a term that you will hear.

    The core sequence functions are first, rest and cons.

    #+BEGIN_SRC clojure
      (defn titleize
	"Documenation: "
	[topic]
	(str topic " for the Brave and True"))
    #+END_SRC

    We can now use titleize as a functional argument as we map to
    the following vector, list, set or hashmap

    #+BEGIN_SRC clojure
      (map titleize ["Hamsters" "Ragnarok"])
      (map titleize '("Empathy" "Decorating"))
      (map titleize #{"Elbows" "Soap Carving"})
      (map #(titleize (second %)) {:uncomfortable-thing "Winking"})
    #+END_SRC

    This is all a bit self-explainitory. 
    map works identically with vectors, lists. It can also work with
    unsorted sets.
    titlize uses the string function which acts on topic which is 
    its argument. topic must be an object that can be "strung" 
    together I suppose.

    This suggests to me that it becomes a bit of a game to get 
    first, rest and cons to work.

*** first, rest, and cons

    If you can perform first, rest and cons on the datastructure
    then it is open to using the seq library in clojure.

    The book goes on to implement an example of how map could be 
    implemented on a linked list in javascript. It then says that
    if first, rest and cons was implemented for another datastructure
    like a vector for example, then map could be used in the exact
    same way.

*** Abstraction Through Direction
     
    We are then briefly told about how different function bodiese 
    are called dependent on the datastructure that is input into 
    the function. A fancy name is given for this which is called 
    polymorphic dispatch. 

    Clojure also does a very light type conversion when any of the 
    functions from the seq library are called. This type conversion
    is performed on the data structure and is called... you guessed
    it 'seq'. 

    #+BEGIN_SRC clojure
      (seq '(1 2 3))
      (seq [1 2 3])
      (seq #{1 2 3})
      (seq {:name "Bill Comopton" :occupation "Dead mopey guy"})
    #+END_SRC   

    2 important details come from this. 

    seq always returns a datastructure that looks like a list. 
    
    The seq of a map {} treats the map as a list of vectors.
    
    To convert a seq back into a map you use into and initialise it 
    with a map {}. 

    #+BEGIN_SRC clojure
      (into {} (seq {:a 1 :b 2 :c 3}))
    #+END_SRC

** Seq Function Examples
*** map

    2 new tasks that map can do: 

    1) multiple collection arguments
    2) collection of functions as argument

    #+BEGIN_SRC clojure
      (map inc [ 1 2 3])
    #+END_SRC

    You can also map multiple collections

    #+BEGIN_SRC clojure
      (map str ["a" "b" "c"] 
	       ["A" "B" "C"]
	       ["1" "2" "3"])
    #+END_SRC

    You can imagine str is being applied to the vertical lists 

    #+BEGIN_SRC clojure
      (list (str "a" "A" "1") (str "b" "B" "2") (str "c" "C" "3"))
    #+END_SRC

    #+RESULTS:
    
    Here is a more interesting example of what you can do with 
    map over multiple collections 

    #+BEGIN_SRC clojure
      (def human-consumption [8.1 7.3 6.6 5.0])
      (def critter-consumpition [0.0 0.2 0.3 1.1])
      (defn unify-diet-data
	"Documenation: "
	[human critter]
	{:human human
	 :critter critter})

      (map unify-diet-data human-consumption critter-consumpition)
    #+END_SRC

    Here is an example of passing map a collection of functions:

    #+BEGIN_SRC clojure
      (def sum #(reduce + %))
      (def avg #(/ (sum %) (count %)))
      (defn stats
	"Documenation: "
	[numbers]
	(map #(% numbers) [sum count avg]))

      (stats [3 4 10])
      (stats [80 1 44 13 6])
    #+END_SRC

    You can see how in stats that each of the arguments 
    are being applied to numbers which results in a table for the
    first example as shown below.


    | sum | count |  avg |
    |-----+-------+------|
    |   3 |     3 |    3 |
    |   4 |     4 |    4 |
    |  10 |    10 |   10 |
    |-----+-------+------|
    |  17 |     3 | 17/3 |
    |     |       |      |


    This is very intriging because you can just spend your time 
    making functions and then the data can just get munged! 

    You can also use map to retrieve data from a map

    #+BEGIN_SRC clojure
      (def identities
	[{:alias "Batman" :real "Bruce Wayne"}
	 {:alias "Spider-Man" :real "Peter Parker"}
	 {:alias "Santa" :real "Your mom"}
	 {:alias "Easter Bunny" :real "Your dad"}])

      (map :real identities)
    #+END_SRC

*** reduce

    Some more ways to use reduce 

    1) trans a map's {} values producing a new map {} with the same 
       keys but with updated values

       #+BEGIN_SRC clojure
	 (reduce (fn [new-map [key val]]
		   (assoc new-map key (inc val)))
		 {}
		 {:max 30 :min 10})
       #+END_SRC

       #+RESULTS:

       Remember how seq functions treat map's {} as a sequence of 
       vectors, so in this the collection that reduce works on 
       becomes ([:max 30] [:min 10]). 

       You can think of the above passiing the first vector-pair
       into assoc

       #+BEGIN_SRC clojure
	 (def first-assoc (assoc {} :max (inc 30)))

	 first-assoc

	 (def second-assoc (assoc first-assoc :min (inc 10)))

	 second-assoc
       #+END_SRC

       #+RESULTS:

       And then it keeps on going to produce the final map {} 
       where the values have 

    2) You can also use reduce to filter out keys from a map 
       based on their value

       #+BEGIN_SRC clojure
	 (reduce (fn [new-map [key val]]
		   (if (> val 4)
		     (assoc new-map key val)
		     new-map))
		 {}
		 {:human 4.1 :critter 3.9})
       #+END_SRC

       Makes sense.

**** Defining map in terms of reduce

     An attempts of this has been made in the ch_4_ex project.

*** take, drop, take-while, and drop-while

    take and drop are from the same family of functions. 
    
    take gives the first n elements of a sequence 

    drop give the sequence with the first n elements removed.  

    #+BEGIN_SRC clojure
      (take 3 [1 2 3 4 5 6 7 8 9 10])

      (drop 3 [1 2 3 4 5 6 7 8 9 10])
    #+END_SRC

    These functions have cousins take-while and drop-while which
    take an additional predicate functional argument.

    #+BEGIN_SRC clojure
      (def food-journal
	[{:month 1 :day 1 :human 5.3 :critter 2.3}
	 {:month 1 :day 2 :human 5.1 :critter 2.0}
	 {:month 2 :day 1 :human 4.9 :critter 2.1}
	 {:month 2 :day 2 :human 5.0 :critter 2.5}
	 {:month 3 :day 1 :human 4.2 :critter 3.3}
	 {:month 3 :day 2 :human 4.0 :critter 3.8}
	 {:month 4 :day 1 :human 3.7 :critter 3.9}
	 {:month 4 :day 2 :human 3.7 :critter 3.6}])
    #+END_SRC

    #+BEGIN_SRC clojure
      (def month-data [1 1 2 2 3 3 4 4])
      (def day-data [1 2 1 2 1 2 1 2])
      (def human-data [5.3 5.1 4.9 5.0 4.2 4.0 3.7 3.7])
      (def critter-data [2.3 2.0 2.1 2.5 3.3 3.8 3.9 3.6])

      (defn unify-month-day-human-critter
	"Documenation: "
	[month day human critter]
	{:month month :day day :human human :critter critter})

      (def food-journal
	(map unify-month-day-human-critter month-data day-data human-data critter-data))
    #+END_SRC

    #+BEGIN_SRC clojure
      (take-while #(< (:month %) 3) food-journal)
    #+END_SRC

    take-while uses the predicate anonymous function takes all
    the values that are less than 3.
    

    #+BEGIN_SRC clojure
      (drop-while #(< (:month %) 3) food-journal)
    #+END_SRC

    here drop-while uses the predicate anonymous function to drop
    all the values that are less that 3. 

    You can use take-while and drop-while in combination

    #+BEGIN_SRC clojure
      (take-while #(< (:month %) 4)
		 (drop-while #(< (:month %) 2) food-journal))
    #+END_SRC
    
    This selects all the data that is in month 3. 
    
*** filter and some 
    
    You use filter to select all the results that match a 
    predicate

    #+BEGIN_SRC clojure
      (filter #(< (:human %) 5) food-journal)
    #+END_SRC

    
    You could have used filter to get the same result as the take
    while from earlier

    #+BEGIN_SRC clojure
      (filter #(< (:month %) 3) food-journal)
    #+END_SRC

    However sometimes you don't want to process the whole list 
    which means that you should use filter. 

    Sometimes you want to know if a collection contains a any 
    values that test true for some predicate. The some function 
    allows you to test this

    #+BEGIN_SRC clojure
      (some #(> (:critter %) 5) food-journal)
      (some #(> (:critter %) 3) food-journal)
    #+END_SRC

    If you want to return the entry that has the critter value 
    equal to 3 you can modify some so that instead of returning 
    true or false it actually returns a value

    #+BEGIN_SRC clojure
      (some #(and (> (:critter %) 3) %) food-journal)
    #+END_SRC

    #+RESULTS:

*** sort and sort-by

    You can sort elements with the sort function 

    #+BEGIN_SRC clojure
      (sort [3 1 2])
    #+END_SRC

    You can also use sort-by which takes an additional functinal
    argument to modify your sorts if you wish. 
    In the following case 'count' modifies the sort which would 
    normally be done alphabetically so that it is instead done 
    by the number of letters that are in the string. 
    I think whatever the function does it must return a number 
    for each element so that the sorting can be done. That would
    be my guess.


    
*** concat

    #+BEGIN_SRC clojure
      (concat [1 2] [3 4])
    #+END_SRC

** Lazy Seqs

   Delaying evaluation is a useful tool. Functions like map 
   and filter return "lazy seqs". This means that their members
   are not accessible until ou try to access them.  
   Deffering computation until it is needed is a very effective 
   way of programming. 

*** Demonstrating Lazy Seq Efficiency
    
    #+BEGIN_SRC clojure
      (def blood-puns [false false true true])
      (def pulse [true true false true])
      (def v_name ["McFishwich" "McMackson" "Damon Salvatore" "Mickey Mouse"])
      (def number [0 1 2 3])

      (defn unify-blood-puns-pulse-v_name
	"Documenation: "
	[blood-puns pulse v_name]
	{:makes-blood-puns? blood-puns :has-pulse? pulse :name v_name})

      (def vampires
	(map unify-blood-puns-pulse-v_name blood-puns pulse v_name))
    #+END_SRC

    Can't build this up using what we've learned so far so here
    is the manual input for vampire-database

    #+BEGIN_SRC clojure
      (def vampire-database
	{0 {:makes-blood-puns? false, :has-pulse? true :name "McFishwich"}
	 1 {:makes-blood-puns? false, :has-pulse? true :name "McMackson"}
	 2 {:makes-blood-puns? true, :has-pulse? false :name "Damon Salvatore"}
	 3 {:makes-blood-puns? true, :has-pulse? true :name "Mickey Mouse"}})
    #+END_SRC

    #+RESULTS:
    : #'user/vampire-database

    We have a very fast function to retrieve each vampire: 

    #+BEGIN_SRC clojure
      (defn vampire-related-details
	"Documenation: "
	[social-security-number]
	(Thread/sleep 1000)
	(get vampire-database social-security-number))
    #+END_SRC

    #+RESULTS:
    : #'user/vampire-related-details

    We then have a function to test whether we have a vampire:

    #+BEGIN_SRC clojure
      (defn vampire?
	"Documenation: "
	[record]
	(and (:makes-blood-puns? record)
	     (not (:has-pulse? record))
	     record))
    #+END_SRC

    #+RESULTS:
    : #'user/vampire?

     #+BEGIN_SRC clojure
      (defn identify-vampire
	"Documenation: "
	[social-security-numbers]
	(first (filter vampire?
		       (map vampire-related-details social-security-numbers))))
    #+END_SRC

    #+RESULTS:
    : #'user/identify-vampire

    vampire-related-details takes one second to loop up an entry
    from the database. vampire returns a record if it passes the 
    vampire test. identify-vampire maps Social Security numbers
    to databse records and then returns the first record that 
    indicates vampirism. 

    #+BEGIN_SRC clojure
      (time (vampire-related-details 0))
    #+END_SRC
    
    The key thing this section is trying to put accross is that 
    map evaluates lazily which means that you can build up 
    a recipe of how functions are applied to a set using map
    but it's only at the point of retrieval that those functions 
    will be evaluated and a value is returned.  

    
    #+BEGIN_SRC clojure
      (time (def mapped-details (map vampire-related-details (range 0 1000000))))
    #+END_SRC

    The first time we decide to realise an element for a lazy seq
    this can take more time. This is because the way that the 
    evaluater does the evaluation is by using chunking, which means
    not only the first element is evaluated but all 30 are evaluated
    for example. 

    This operation takes barely any time at all. This is because 
    range returns a lazy sequence that isn't realised and then 
    map is applied to this sequence to return another sequence, 
    which also isn't realised. Doing things this way means that 
    we are telling the computer how to evaluate something without 
    it actually performing the evaluation. This saves time. 

    There are two parts two a lazy seq. A recipe for how to realize
    the elements of a sequence and the elements that have been 
    realized so far.

    Every time you request an unrealized element, the lazy seq will
    use its recipe to generate the requested element.

    #+BEGIN_SRC clojure
      (time (first mapped-details))
    #+END_SRC

    However when an element is realized a chunk of elements are 
    realised, not just one, this means the first time things are
    realised this takes more time. However once they are realised
    they are much quicker to realise which is why when you evaluate
    this a second time then you get a much quicker time.

*** Infinite Sequences

    There are a few functions in Clojure that allow you to create
    infinite sequences. 

    
    #+BEGIN_SRC clojure
      (concat (take 8 (repeat "na")) ["Batman!"])
    #+END_SRC

    There is also the function repeatedly which allows you to 
    provide a function so that you can to generate each element 
    in the sequence. 


    #+BEGIN_SRC clojure
      (take 3 (repeatedly (fn [] (rand-int 10))))
    #+END_SRC

    
    #+BEGIN_SRC clojure
      (defn even-numbers
	"Documenation: "
	([] (even-numbers 0))
	([n] (cons n (lazy-seq (even-numbers (+ n 2))))))
    #+END_SRC

    So yeah this is how you creatte an infinite list of even 
    numbers. When you want to realize this list you could do the 
    follow to get the first 10. 


    #+BEGIN_SRC clojure
      (take 10 (even-numbers))
    #+END_SRC

** The Collection Abstraction

   There are a couple of initial functions that are associated
   with this abstraction 


   #+BEGIN_SRC clojure
     (empty? [])
   #+END_SRC

   #+RESULTS:
   : true

   #+BEGIN_SRC clojure
     (empty? ["no!"])
   #+END_SRC

   #+RESULTS:
   : false

*** into    
    
    One of the most important collection functions is into.
    Many seq functions return a seq and often you want to convert
    back to the original data structure that you were working 
    with and so into allows you to do that. 
    #+BEGIN_SRC clojure
      (map identity {:sunlight-reaction "Glitter!"})
    #+END_SRC

    As we know indentity is the function that returns the thing
    without any change.

    
    #+BEGIN_SRC clojure
      (into {} (map identity {:sunlight-reaction "Glitter!"}))
    #+END_SRC

    into doesn't just work with maps {} it also works with vectors
    as well 

    
    #+BEGIN_SRC clojure
      (map identity [:garlic :sesame-oil :fried-eggs])

      (into [] (map identity [:garlic :sesame-oil :fried-eggs]))
    #+END_SRC

    You can also use into to go from one data structure to another

    
    #+BEGIN_SRC clojure
      (map identity [:garlic-clove :garlic-clove])

      (into #{} (map identity [:garlic-clove :garlic-clove]))
    #+END_SRC

    The first argument of into doesn't have to be empty either


    Below is how you add elements to a map
    
    #+BEGIN_SRC clojure
      (into {:favorite-emotion "gloomy"} [[:sunlight-reaction "glitter!"]])
    #+END_SRC
    
    And below is how you can add elements to a vector.

    #+BEGIN_SRC clojure
      (into ["Cherry"] '("pine" "spruce"))
    #+END_SRC

    You can also expand a map {} using into 


    #+BEGIN_SRC clojure
      (into {:favorite-animal "kitty"} {:least-favorite-smell "dog"
					:relationship-with-teenager "creepy"})
    #+END_SRC

    into is awesome at taking two collections and adding all the 
    elements of the second into the first. 

*** conj

    conj adds elements to a collection, but it does it in a slightly 
    different way. 

    
    #+BEGIN_SRC clojure
      (conj [0] [1])
    #+END_SRC

    #+RESULTS:
    This results in the vector [1] going inside the vector [0]
    so we get something that looks like [0 [1]]. This is different
    to how into works which is like the following 


    #+BEGIN_SRC clojure
      (into [0] [1])
    #+END_SRC

    #+RESULTS:
    This results in a flattened vector [0 1]

    If we wanted the same result as into above using conj we would
    have to do the following 

    #+BEGIN_SRC clojure
      (conj [0] 1)
    #+END_SRC

    This means that scalars can be passed into a datastructure 
    using conj. When using into the other thing must be a 
    collection. This is the main difference. 

    
    #+BEGIN_SRC clojure
      (conj [0] 1 2 3 4)
    #+END_SRC

    With conj you can supply as many elements as you like to a 
    collection like you see above. 

    Or you can use conj to add elements to other collections 

    
    #+BEGIN_SRC clojure
      (conj {:time "midnight"} [:place "ye olde cemtarium"])
    #+END_SRC

    conj and into are so similar that you could define conj 
    in terms of into 

    
    #+BEGIN_SRC clojure
      (defn my-conj
	"Documenation: "
	[target & additions]
	(into target additions))
    #+END_SRC

** Function Functions

*** apply

    apply explodes a seqable data structure so it can be passed
    to a function that expects a rest parameter. 

    An example of a function that expects a rest parameter is 
    max. 


    #+BEGIN_SRC clojure
      (max 0 1 2)
    #+END_SRC

    This means that you can't just pass a collection because 
    max can't make sense of 

    
    #+BEGIN_SRC clojure
      (max [0 1 2])
    #+END_SRC

    There is no such thing as a max of a vector. 

    however... apply allows the max to be found so that the data 
    can be passed into 


    #+BEGIN_SRC clojure
      (apply max [0 1 2])
    #+END_SRC

    Here apply exploded the elemetns of the vector so that they 
    are passed to max as arguments. 

    You can also use a combination of apply and conj to redefine 
    into 


    #+BEGIN_SRC clojure
      (defn my-into
	[target additions]
	(apply conj target additions))
    #+END_SRC

    I think of apply as having the power to remove the braces 
    from a collection and then feed that collection into a function
    that expects a variable number of arguments, like max. 

    The following to satements are equivalent


    #+BEGIN_SRC clojure
      (my-into [0] [1 2 3])

      (conj [0] 1 2 3)
    #+END_SRC

*** into and conj summary

    into and conj both add things to collections but there is a 
    difference. 

    into adds 1 other collection to an original collection 

    conj adds any numbers of scalars to a collection

    That's the key. 

    apply allows you to define into in terms of conj because 
    apply will explode the second collection which is supplied to 
    into 


*** partial 
    
    partial takes a function and any number of arguments. 
    it then returns a new function. When you call this function
    the originally supplied function is called with the original
    argumuments you supplied it along with the new arguments


    #+BEGIN_SRC clojure
      (def add10 (partial + 10))

      (add10 3)

      (add10 5)
    #+END_SRC

    We could define a more complex function that uses partial 

    
    #+BEGIN_SRC clojure
      (def add-missing-elements (partial conj ["water" "earth" "air"]))

      (add-missing-elements "unobtainium" "adamantium")
    #+END_SRC

    partial basically allows you to to write unfinished expressions
    which are functions. Then you can fill out the rest of the 
    function later on by supplying arguments to your new partial
    function. 

    Here is a way that you define partial


    #+BEGIN_SRC clojure
      (defn my-partial
	"Documenation: "
	[partialized-fn & args]
	(fn [& more-args]
	  (apply partialized-fn (into args more-args))))
    #+END_SRC

    #+RESULTS:
    : #'user/my-partial

    You can see how my-partial defintely returns a function, 
    so what is the nature of that function? 

    Well this function that is returned must take a function and 
    a rest parameter of args as input parameters. 
    And then a function is returned which applies the supplied 
    function to a collection which is the combination of args 
    and more-args. However args and more-args can't be realised 
    until more-args are supplied when the partial function is used

    
    #+BEGIN_SRC clojure
      (def add20 (my-partial + 20))

      (add20 30)
    #+END_SRC

    #+RESULTS:
    : #'user/add20

    Partial is cooool. 

    So when do you want to use partials in general? 

    If you are repeating the same combination of function and 
    arguements in many different contexts, this is the time to 
    use partial.

    
    #+BEGIN_SRC clojure
      (defn lousy-logger
	"Documenation: "
	[log-level message]
	(condp = log-level
	    :warn (clojure.string/lower-case message)
	    :emergency (clojure.string/upper-case message)))
    #+END_SRC

    We could then define a function warn using partial which 
    will always return a lower-case message. This is the same 
    as calling the lousy-logger directly. 


    #+BEGIN_SRC clojure
      (def warn (partial lousy-logger :warn))

      (warn "Red light ahead")
    #+END_SRC

    Partial is another tool of indirection. 

*** complement 

    complement is an abstraction that allows you to quickly 
    define the opposite of a defined predicate. 


    #+BEGIN_SRC clojure
      (defn identify-humans
	"Documenation: "
	[social-security-numbers]
	(filter #(not (vampire? %))
		(map vampire-related-details social-security-numbers)))
    #+END_SRC

    #(not (vampire? %)) is a common function syntax that has its 
    own abstraction so that we get the same idea with less
    syntax


    #+BEGIN_SRC clojure
      (def not-vampire? (complement vampire?))

      (defn identify-humans
	"Documenation: "
	[social-security-numbers]
	(filter not-vampire?
		(map vampire-related-details social-security-numbers)))
    #+END_SRC

    Here's how you might define complement


    #+BEGIN_SRC clojure
      (defn my-complement
	"Documenation: "
	[fun]
	(fn [& args]
	  (not (apply fun args))))
    #+END_SRC

    And here is an example of using my-complement


    #+BEGIN_SRC clojure
      (def my-pos? (complement neg?))

      (my-pos? 1)

      (my-pos? -1)
    #+END_SRC

** A Vampire Data Analysis Program for the FWPD

   

** Summ	
* Chapter 5: Functional Programming

  In this chapter you are going to learn about what exactly a pure function
  is and why they are so useful. How to work with immutable data structures
  and why they're uperior to their mutable cousins. How disentangling data
  and functions gives you more power and flexiblility and why it's powerful
  to program to a small set of data abstractions. This will give you a new 
  set of tools to be able to solve problems. 

** Pure Functions: What and Why

   A pure function has 2 properties: 

   1) When applied to the same arguments it returns the same result.
      The technical term for this is referential transparency.

      The rand function is not referentially transparent because when it 
      is applied to the same arguments it does not always return the same 
      result.

   2) It can't cause any side effects. The function cannot make any 
      changes to things that are outside of its scope. Within it's scope 
      things can change, but outside things can't change. 
      Therefore it can't make changes to an externally accessible mutable
      object or write to a file.

   The first benefit of these two properties is that pure functions 
   can't break other parts of a system meaning is one less thing to have to 
   worry about. The second benefit is they are consistent, passing in the 
   same arguments will always return the same result. 

*** Pure Functons Are Referentially Transparent

    To ensure that a function is Referentially Transparent (that when it 
    is applied to the same arguments it returns the same result) there are 
    2 things that a pure function relies on 

    1) their own arguments 
    2) immutable values to determine their own value 

    Mathematical functions are Referentially Transparent

    #+BEGIN_SRC clojure
      (+ 1 2)
    #+END_SRC

    A function that relies on an immutable value is referentially transparent.
    The string ", Daniel-san" is immutable, so the following function is also 
    Referentially Transparent

    #+BEGIN_SRC clojure
      (defn wisdom
	"Documenation: "
	[words]
	(str words ",Daniel-san"))
    #+END_SRC

    And here's an example of its use


    #+BEGIN_SRC clojure
      (wisdom "Alwas bathe on Firdays")
    #+END_SRC

    Here are a couple of example of functions that are not Referentially 
    Transparent (a function that when applied to some arguments returns 
    the same result).

    #+BEGIN_SRC clojure
      (defn year-end-evaluation
	"Documenation: "
	[]
	(if (> (rand) 0.5)
	  "You get a raise!"
	  "Better luck next year!"))
    #+END_SRC

    A function that reads from a file is not Referentially Transparent 
    because a file's contents is liable to change.

    #+BEGIN_SRC clojure
      (defn analysis
	"Documenation: "
	[text]
	(str "Character count: " (count text)))

      (defn analyze-file
	"Documenation: "
	[filename]
	(analysis (slurp filename)))
    #+END_SRC

    If a function is Referentially Transparent yo never have to consider
    what possible external conditions could affect the return value of 
    the function. This is especially the case if the function is used in
    multiple places


*** Pure Functions Have No Side Effects
** Living with Immutable Data Structures
*** Recursion Instead of for/while
*** Function Composition Instead of Attribute Mutation
** Cool Things to Do with Pure Functions
*** comp
*** memoize
** Peg Thing 
*** Playing
*** Code Organization#
*** Creating the Board
*** Moving Pegs
*** Rendering and Printing the Board
*** Player Interaction
** Summary

